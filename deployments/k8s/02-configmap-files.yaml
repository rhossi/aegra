apiVersion: v1
kind: ConfigMap
metadata:
  name: aegra-config-files
  namespace: aegra
  labels:
    app.kubernetes.io/name: aegra
    app.kubernetes.io/part-of: aegra
data:
  # aegra.json - Main configuration file
  aegra.json: |
    {
      "version": "0.1.0",
      "name": "aegra",
      "description": "Aegra Agent Protocol Server"
    }
  
  # auth.py - Authentication module
  auth.py: |
    # Authentication module for Aegra
    # This file should be customized based on your authentication needs
    
    def get_auth_backend():
        """Get authentication backend"""
        # Implement your authentication logic here
        pass
    
    def on_auth_error(request, exc):
        """Handle authentication errors"""
        # Implement your error handling logic here
        pass
  
  # .env - Environment variables
  .env: |
    # Environment variables for Aegra
    # Add your environment-specific variables here
    DEBUG=true
    AUTH_TYPE=noop
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: aegra-alembic-files
  namespace: aegra
  labels:
    app.kubernetes.io/name: aegra
    app.kubernetes.io/part-of: aegra
data:
  # alembic.ini - Database migration configuration
  alembic.ini: |
    # A generic, single database configuration.

    [alembic]
    # path to migration scripts
    script_location = alembic

    # template used to generate migration file names; The default value is %%(rev)s_%%(slug)s
    # Uncomment the line below if you want the files to be prepended with date and time
    # file_template = %%(year)d_%%(month).2d_%%(day).2d_%%(hour).2d%%(minute).2d-%%(rev)s_%%(slug)s

    # sys.path path, will be prepended to sys.path if present.
    # defaults to the current working directory.
    prepend_sys_path = .

    # timezone to use when rendering the date within the migration file
    # as well as the filename.
    # If specified, requires the python-dateutil library that can be
    # installed by adding `alembic[tz]` to the pip requirements
    # string value is passed to dateutil.tz.gettz()
    # leave blank for localtime
    # timezone =

    # max length of characters to apply to the
    # "slug" field
    # truncate_slug_length = 40

    # set to 'true' to run the environment during
    # the 'revision' command, regardless of autogenerate
    # revision_environment = false

    # set to 'true' to allow .pyc and .pyo files without
    # a source .py file to be detected as revisions in the
    # versions/ directory
    # sourceless = false

    # version number format
    version_num_format = %04d

    # version path separator; As mentioned above, this is the character used to split
    # version_locations. The default within new alembic.ini files is "os", which uses
    # os.pathsep. If this key is omitted entirely, it falls back to the legacy
    # behavior of splitting on spaces and/or commas.
    # Valid values for version_path_separator are:
    #
    # version_path_separator = :
    # version_path_separator = ;
    # version_path_separator = space
    version_path_separator = os

    # the output encoding used when revision files
    # are written from script.py.mako
    # output_encoding = utf-8

    sqlalchemy.url = postgresql+asyncpg://user:password@postgres-service:5432/aegra


    [post_write_hooks]
    # post_write_hooks defines scripts or Python functions that are run
    # on newly generated revision scripts.  See the documentation for further
    # detail and examples

    # format using "black" - use the console_scripts runner, against the "black" entrypoint
    # hooks = black
    # black.type = console_scripts
    # black.entrypoint = black
    # black.options = -l 79 REVISION_SCRIPT_FILENAME

    # Logging configuration
    [loggers]
    keys = root,sqlalchemy,alembic

    [handlers]
    keys = console

    [formatters]
    keys = generic

    [logger_root]
    level = WARN
    handlers = console
    qualname =

    [logger_sqlalchemy]
    level = WARN
    handlers =
    qualname = sqlalchemy.engine

    [logger_alembic]
    level = INFO
    handlers =
    qualname = alembic

    [handler_console]
    class = StreamHandler
    args = (sys.stderr,)
    level = NOTSET
    formatter = generic

    [formatter_generic]
    format = %(levelname)-5.5s [%(name)s] %(message)s
    datefmt = %H:%M:%S

  # env.py - Alembic environment file
  env.py: |
    """Alembic environment configuration for Aegra database migrations."""

    import asyncio
    import os
    from logging.config import fileConfig

    from dotenv import load_dotenv
    from sqlalchemy import pool
    from sqlalchemy.engine import Connection
    from sqlalchemy.ext.asyncio import async_engine_from_config

    from alembic import context

    # Import your SQLAlchemy models here
    from src.agent_server.core.orm import Base

    # Load environment variables from a .env file if present
    load_dotenv()

    # This is the Alembic Config object, which provides
    # access to the values within the .ini file in use.
    config = context.config

    # Interpret the config file for Python logging.
    # This line sets up loggers basically.
    if config.config_file_name is not None:
        fileConfig(config.config_file_name)

    # add your model's MetaData object here
    # for 'autogenerate' support
    target_metadata = Base.metadata

    # other values from the config, defined by the needs of env.py,
    # can be acquired:
    # my_important_option = config.get_main_option("my_important_option")
    # ... etc.


    def get_url():
        """Get database URL from environment or config."""
        return os.getenv("DATABASE_URL", config.get_main_option("sqlalchemy.url"))


    def run_migrations_offline() -> None:
        """Run migrations in 'offline' mode.

        This configures the context with just a URL
        and not an Engine, though an Engine is acceptable
        here as well.  By skipping the Engine creation
        we don't even need a DBAPI to be available.

        Calls to context.execute() here emit the given string to the
        script output.

        """
        url = get_url()
        context.configure(
            url=url,
            target_metadata=target_metadata,
            literal_binds=True,
            dialect_opts={"paramstyle": "named"},
        )

        with context.begin_transaction():
            context.run_migrations()


    def do_run_migrations(connection: Connection) -> None:
        """Run migrations with the given connection."""
        context.configure(connection=connection, target_metadata=target_metadata)

        with context.begin_transaction():
            context.run_migrations()


    async def run_async_migrations() -> None:
        """In this scenario we need to create an Engine
        and associate a connection with the context.

        """
        configuration = config.get_section(config.config_ini_section)
        configuration["sqlalchemy.url"] = get_url()

        connectable = async_engine_from_config(
            configuration,
            prefix="sqlalchemy.",
            poolclass=pool.NullPool,
        )

        async with connectable.connect() as connection:
            await connection.run_sync(do_run_migrations)

        await connectable.dispose()


    def run_migrations_online() -> None:
        """Run migrations in 'online' mode."""
        asyncio.run(run_async_migrations())


    if context.is_offline_mode():
        run_migrations_offline()
    else:
        run_migrations_online()

  # script.py.mako - Alembic migration template
  script.py.mako: |
    """${message}

    Revision ID: ${up_revision}
    Revises: ${down_revision | comma,n}
    Create Date: ${create_date}

    """
    from alembic import op
    import sqlalchemy as sa
    ${imports if imports else ""}

    # revision identifiers, used by Alembic.
    revision = ${repr(up_revision)}
    down_revision = ${repr(down_revision)}
    branch_labels = ${repr(branch_labels)}
    depends_on = ${repr(depends_on)}


    def upgrade() -> None:
        ${upgrades if upgrades else "pass"}


    def downgrade() -> None:
        ${downgrades if downgrades else "pass"}
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: aegra-src-files
  namespace: aegra
  labels:
    app.kubernetes.io/name: aegra
    app.kubernetes.io/part-of: aegra
data:
  # This ConfigMap will be populated with the source code files
  # In a real deployment, you would create this from your source directory
  # For now, we'll create a placeholder
  __init__.py: |
    # Placeholder for src/__init__.py
    pass
